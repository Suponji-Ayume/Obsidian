# 一、& 和 | 之间互有分配律成立
+ $a \ \&\ (b \ |\  c) = (a \ \& \  b)\ | \ (a \ \& \ c)$
+ $a \ | \ (b \ \& \ c) = (a \ | \ b) \ \& \ (a \ | \ c)$
<br>
# 二、异或运算的用途

1. **对于给定的位向量的指定位置按位取反**
	 + $0 \bigoplus 0 = 0$
	 + $1 \bigoplus 1 = 0$
	 + $1 \bigoplus 0 = 0 \bigoplus 1 = 1$

	PS: 注意到：0 和 1 按位与 1 做异或运算，都相当于取反
	e.g. 将 $010101_{2}$ 的第 2、3 位取反:  $010101_{2} \bigoplus 000110_{2}$
<br>
2. 交换两个元素
	```C
	#include <stdio.h>
	
	void inplace_swap(int *x, int *y)
	{
	    *y = *x ^ *y;
	    *x = *x ^ *y;
	    *y = *x ^ *y;
	}
	
	int main()
	{
	    int a, b;
	    scanf("%d %d", &a, &b);
	    printf("a = %d, b = %d\n", a, b);
	    inplace_swap(&a, &b);
	    printf("a = %d, b = %d\n", a, b);
	    return 0;
	}```


```C
/**

* @brief 将数组逆序排列

*

* @param a 数组名，也即数组首地址，以整数数组为例

* @param cnt 数组长度

* @details 注意循环条件是 first < last 不能等于，否则奇数数组的最中间值会经过异或运算变为 0

*/

void reverse_array(int a[], int cnt)

{

int first, last;

for (first = 0, last = cnt - 1; first < last; first++, last--)

{

inplace_swap(a[first], a[last]);

}

}
```